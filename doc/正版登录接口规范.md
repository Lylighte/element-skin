基于提供的 Java 代码 (`MicrosoftService.java`, `MicrosoftSession.java` 等)，以下是一份语言无关的 **Minecraft 微软账户登录流程 API 文档**。

这份文档详细描述了从微软 OAuth 令牌交换到获取 Minecraft 最终访问令牌（Access Token）及用户配置文件的完整技术细节。

---

# Minecraft 微软账户登录流程文档

本文档描述了如何通过微软账户（Microsoft Account / MSA）验证并登录 Minecraft Java 版。该流程主要包含以下步骤：

1.  **微软 OAuth 2.0 认证**：获取微软访问令牌。
2.  **Xbox Live (XBL) 认证**：将微软令牌交换为 Xbox Live 令牌。
3.  **XSTS 认证**：获取 Xbox 安全令牌服务令牌。
4.  **Minecraft 认证**：获取 Minecraft 访问令牌。
5.  **游戏所有权检查**：确认账号拥有游戏。
6.  **获取档案**：获取玩家 UUID 和皮肤信息。

## 1. 微软 OAuth 2.0 认证
对于网站（Web 应用）而言，集成 Minecraft 正版登录的标准做法是使用 **OAuth 2.0 授权码模式 (Authorization Code Flow)**。

这与桌面端应用（如启动器）的主要区别在于：网站被视为“机密客户端 (Confidential Client)”，可以安全地保存 `client_secret`，并通过浏览器重定向的方式完成用户授权，体验更流畅且安全。

以下是针对网站开发的详细 API 文档。

---

# Minecraft 网站登录集成文档 (Web / Server-Side)

## 0. 前置准备：Azure 应用注册

在开始编码前，必须在 Microsoft Azure 门户注册一个应用以获取凭据。

1.  **注册应用**:
    *   访问 [Azure Portal - App Registrations](https://portal.azure.com/#view/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/~/RegisteredApps)。
    *   点击 **"New registration"**。
    *   **Name**: 填写你的网站名称（如 "My Minecraft Website"）。
    *   **Supported account types**: **必须选择** `Accounts in any organizational directory (Any Azure AD directory - Multitenant) and personal Microsoft accounts (e.g. Skype, Xbox)`。
        *   *注意：如果选错（如只选单租户），个人玩家将无法登录。*
    *   **Redirect URI**:
        *   Platform: 选择 **Web**。
        *   URI: 填写你的回调地址（例如 `https://your-website.com/auth/callback`）。此地址必须与代码中完全一致。
    *   点击 **Register**。

2.  **获取凭据**:
    *   **Client ID**: 在应用概览页复制 `Application (client) ID`。
    *   **Client Secret**:
        *   点击左侧菜单 **"Certificates & secrets"** -> **"New client secret"**。
        *   创建后立即复制 **Value**（离开页面后将不可见）。

---

## 1. 微软 OAuth 2.0 授权 (Authorization Code Flow)

### 1.1 重定向用户登录
当用户点击“使用微软登录”时，将其浏览器重定向到以下 URL。

*   **Endpoint**: `GET https://login.microsoftonline.com/consumers/oauth2/v2.0/authorize`
*   **适用场景**: 浏览器端跳转。

| 参数 | 值 / 说明 |
| :--- | :--- |
| `client_id` | 你的 **Client ID**。 |
| `response_type` | `code` (表示请求授权码)。 |
| `redirect_uri` | 你的回调地址 (必须与 Azure 后台配置的完全一致，需 URL Encode)。 |
| `scope` | `XboxLive.signin offline_access` <br> *注：`offline_access` 用于获取刷新令牌，建议加上。* |
| `state` | (可选) 生成一个随机字符串，用于防止 CSRF 攻击。 |

**完整 URL 示例**:
```http
https://login.microsoftonline.com/consumers/oauth2/v2.0/authorize?client_id=YOUR_CLIENT_ID&response_type=code&redirect_uri=https%3A%2F%2Fyour-website.com%2Fauth%2Fcallback&scope=XboxLive.signin%20offline_access&state=12345
```

> **关于 Scope 的说明**: `XboxLive.signin` 可能无法在 Azure 门户的“API 权限”列表中找到，这是正常的。直接在代码请求中包含此 Scope 即可，微软会在用户登录时动态提示授权。

### 1.2 处理回调并获取 Authorization Code
用户登录并授权后，微软会将浏览器重定向回你的 `redirect_uri`，并附带 `code` 参数。

*   **URL 示例**: `https://your-website.com/auth/callback?code=M.R3_BAY.6...&state=12345`
*   **后端处理**: 接收并提取 URL 中的 `code` 参数值。

### 1.3 兑换微软 Access Token (服务器端)
后端服务器使用 `code` 向微软交换 Access Token。此步骤必须在后端进行，因为需要使用 `client_secret`。

*   **Endpoint**: `POST https://login.microsoftonline.com/consumers/oauth2/v2.0/token`
*   **Content-Type**: `application/x-www-form-urlencoded`

**请求参数**:

| 参数 | 值 |
| :--- | :--- |
| `client_id` | 你的 **Client ID**。 |
| `client_secret` | 你的 **Client Secret**。 |
| `code` | 上一步获取的 `code`。 |
| `redirect_uri` | 必须与步骤 1.1 中的完全一致。 |
| `grant_type` | `authorization_code` |

**响应 (JSON)**:
```json
{
  "token_type": "Bearer",
  "scope": "XboxLive.signin offline_access ...",
  "expires_in": 3600,
  "access_token": "EwBQ...", // <--- 微软访问令牌，用于下一步
  "refresh_token": "M.R3...", // <--- 保存此令牌用于日后刷新
  "user_id": "..."
}
```

---

## 2. Xbox Live 认证 (服务器端)

拿到微软 `access_token` 后，接下来的流程与桌面端一致，但必须在你的服务器后端完成，避免暴露令牌。

*   **Endpoint**: `POST https://user.auth.xboxlive.com/user/authenticate`
*   **请求**:
    ```json
    {
      "Properties": {
        "AuthMethod": "RPS",
        "SiteName": "user.auth.xboxlive.com",
        "RpsTicket": "d=<MICROSOFT_ACCESS_TOKEN>" // 注意前面的 d=
      },
      "RelyingParty": "http://auth.xboxlive.com",
      "TokenType": "JWT"
    }
    ```
*   **响应**: 获取 `Token` (Xbox Token) 和 `uhs` (User Hash)。

---

## 3. XSTS 认证 (服务器端)

*   **Endpoint**: `POST https://xsts.auth.xboxlive.com/xsts/authorize`
*   **请求**:
    ```json
    {
      "Properties": {
        "SandboxId": "RETAIL",
        "UserTokens": [ "<XBOX_TOKEN>" ]
      },
      "RelyingParty": "rp://api.minecraftservices.com/",
      "TokenType": "JWT"
    }
    ```
*   **响应**: 获取 `Token` (XSTS Token)。

---

## 4. Minecraft 认证 (服务器端)

*   **Endpoint**: `POST https://api.minecraftservices.com/authentication/login_with_xbox`
*   **请求**:
    ```json
    {
      "identityToken": "XBL3.0 x=<UHS>;<XSTS_TOKEN>"
    }
    ```
*   **响应**:
    ```json
    {
      "username": "UUID",
      "access_token": "eyJhbG...", // <--- 最终的 Minecraft Access Token
      "expires_in": 86400
    }
    ```

---

## 5. 验证游戏所有权与获取资料 (服务器端)

最后，使用 Minecraft Access Token 确认用户是否购买了游戏，并获取其用户名。

*   **步骤 A (检查权限)**: `GET https://api.minecraftservices.com/entitlements/mcstore`
    *   Header: `Authorization: Bearer <MINECRAFT_ACCESS_TOKEN>`
    *   检查响应 `items` 列表是否包含游戏。如果列表为空，说明用户没买游戏（可能是 Demo 版）。

*   **步骤 B (获取档案)**: `GET https://api.minecraftservices.com/minecraft/profile`
    *   Header: `Authorization: Bearer <MINECRAFT_ACCESS_TOKEN>`
    *   **响应**:
        ```json
        {
          "id": "cdb5aee80f904fdda63b7d1d0c45952e", // 真实 UUID
          "name": "Steve", // 游戏内用户名
          "skins": [ ... ]
        }
        ```

---

## 最佳实践总结

1.  **Session 管理**: 登录成功后，你应该在你的网站数据库中创建用户 Session，将 Minecraft UUID 与你的网站用户 ID 绑定。
2.  **令牌存储**:
    *   **不要**把 `client_secret` 暴露在前端代码中。
    *   **不要**把 Minecraft Access Token 返回给前端，除非必须。建议仅在后端使用它来验证身份，然后发放你自己的网站 Session Cookie。
    *   安全存储 `refresh_token`。如果用户 Session 过期，后端可以使用 `refresh_token` 自动重新走一遍流程，而无需用户重新点击登录。
3.  **刷新流程**:
    *   Endpoint: `POST https://login.microsoftonline.com/consumers/oauth2/v2.0/token`
    *   Payload: `client_id`, `client_secret`, `refresh_token`, `grant_type=refresh_token`。
---

## 2. Xbox Live (XBL) 认证

将微软 OAuth 的 Access Token 交换为 Xbox Live 令牌。

*   **Endpoint**: `POST https://user.auth.xboxlive.com/user/authenticate`
*   **Content-Type**: `application/json`
*   **Accept**: `application/json`

### 请求体 (JSON)
```json
{
  "Properties": {
    "AuthMethod": "RPS",
    "SiteName": "user.auth.xboxlive.com",
    "RpsTicket": "d=<MICROSOFT_ACCESS_TOKEN>" 
  },
  "RelyingParty": "http://auth.xboxlive.com",
  "TokenType": "JWT"
}
```
*   注意：`RpsTicket` 的值必须以 `d=` 开头，后跟步骤 1 获取的令牌。

### 响应体 (JSON)
成功 (HTTP 200):
```json
{
  "IssueInstant": "2020-12-07T19:52:08.4463796Z",
  "NotAfter": "2020-12-21T19:52:08.4463796Z",
  "Token": "<XBL_TOKEN>",
  "DisplayClaims": {
    "xui": [
      {
        "uhs": "<USER_HASH>"
      }
    ]
  }
}
```

*   **关键数据提取**:
    *   `Token`: 用于下一步。
    *   `DisplayClaims.xui[0].uhs`: 用户哈希 (User Hash String)，后续步骤必须使用。

---

## 3. XSTS 认证 (Xbox Secure Token Service)

获取 XSTS 令牌，这是连接 Minecraft 服务所需的凭证。

*   **Endpoint**: `POST https://xsts.auth.xboxlive.com/xsts/authorize`
*   **Content-Type**: `application/json`

### 请求体 (JSON)
```json
{
  "Properties": {
    "SandboxId": "RETAIL",
    "UserTokens": [
      "<XBL_TOKEN>"
    ]
  },
  "RelyingParty": "rp://api.minecraftservices.com/",
  "TokenType": "JWT"
}
```

### 响应体 (JSON)
成功 (HTTP 200):
```json
{
  "IssueInstant": "...",
  "NotAfter": "...",
  "Token": "<XSTS_TOKEN>",
  "DisplayClaims": {
    "xui": [
      {
        "uhs": "<USER_HASH>"
      }
    ]
  }
}
```
*   **校验**: 响应中的 `uhs` 应与步骤 2 中的 `uhs` 一致。
*   **错误处理**:
    *   **HTTP 401**: 通常意味着该微软账户没有 Xbox 档案。
    *   **XErr 2148916233**: 缺少 Xbox 账号，用户需要去 Xbox 官网注册。
    *   **XErr 2148916238**: 儿童账号未添加到家庭组或被家长控制限制。
    *   **XErr 2148916235**: 所在国家/地区不可用。

---

## 4. Minecraft 认证

使用 XSTS 令牌登录 Minecraft 服务，获取最终的游戏访问令牌。

*   **Endpoint**: `POST https://api.minecraftservices.com/authentication/login_with_xbox`
*   **Content-Type**: `application/json`

### 请求体 (JSON)
```json
{
  "identityToken": "XBL3.0 x=<USER_HASH>;<XSTS_TOKEN>"
}
```
*   注意格式严格为 `XBL3.0 x=` 加上 `uhs`，分号，然后是 `XSTS Token`。

### 响应体 (JSON)
成功 (HTTP 200):
```json
{
  "username": "<UUID_STRING>", 
  "roles": [],
  "access_token": "<MINECRAFT_ACCESS_TOKEN>",
  "token_type": "Bearer",
  "expires_in": 86400
}
```
*   **输出**: `access_token` 是访问 Minecraft API（如获取皮肤、加入服务器）的最终凭证。
*   **过期时间**: 这里的 `expires_in` (秒) 加上当前时间即为 `NotAfter` 时间。

---

## 5. 游戏所有权检查 (Entitlements)

验证该账户是否实际购买了 Minecraft Java 版。这是一个关键步骤，即使获取了 Token，如果没有购买，也只能玩 Demo 版。

*   **Endpoint**: `GET https://api.minecraftservices.com/entitlements/mcstore`
*   **Authorization**: `Bearer <MINECRAFT_ACCESS_TOKEN>`

### 响应
*   **HTTP 200**: 拥有游戏权限。响应体包含签名密钥，一般客户端只需检查状态码是否为 200 且 items 列表是否非空。
*   **非 200**: 验证失败或无权访问。

---

## 6. 获取 Minecraft 档案 (Profile)

获取玩家的游戏内 UUID、用户名和皮肤信息。

*   **Endpoint**: `GET https://api.minecraftservices.com/minecraft/profile`
*   **Authorization**: `Bearer <MINECRAFT_ACCESS_TOKEN>`

### 响应体 (JSON)
成功 (HTTP 200):
```json
{
  "id": "cdb5aee80f904fdda63b7d1d0c45952e",
  "name": "PlayerName",
  "skins": [
    {
      "id": "...",
      "state": "ACTIVE",
      "url": "http://textures.minecraft.net/texture/...",
      "variant": "CLASSIC",
      "alias": "STEVE"
    }
  ],
  "capes": []
}
```
*   **错误处理**:
    *   **HTTP 404**: 用户已登录，但未创建 Minecraft Java 版档案（即没有设置游戏名）。

---

## 7. 其他操作

### 刷新令牌 (Session Refresh)
当 Minecraft Access Token 过期时（通常 24 小时）：
1.  使用保存的微软 OAuth `refresh_token` 重新执行 **步骤 1** 获取新的微软 Access Token。
2.  重复 **步骤 2, 3, 4, 6** 以获取新的 Minecraft Access Token 和校验档案。
3.  如果档案 UUID 发生变化，应视为无效会话。

### 上传皮肤
*   **Endpoint**: `POST https://api.minecraftservices.com/minecraft/profile/skins`
*   **Authorization**: `Bearer <MINECRAFT_ACCESS_TOKEN>`
*   **Content-Type**: `multipart/form-data`
*   **参数**:
    *   `variant`: "classic" (Steve) 或 "slim" (Alex)。
    *   `file`: 图片文件流 (PNG)。

---

## 数据结构摘要

### 会话存储 (Storage Model)
建议客户端持久化存储以下信息以便下次自动登录：
*   `uuid`: 游戏角色 UUID。
*   `displayName`: 游戏角色名称。
*   `accessToken`: Minecraft 访问令牌。
*   `refreshToken`: **微软 OAuth 刷新令牌** (最重要，用于长期登录)。
*   `notAfter`: 令牌过期时间戳。
*   `userid`: 微软用户 ID。